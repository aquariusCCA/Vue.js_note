在網頁開發的早期，js製作作為一種腳本語言，做一些簡單的表單驗證或動畫實現等，
那個時候代碼還是很少的。
	- 那個時候的代碼怎麼寫的 ?
	Ans: 直接將代碼寫在 <script> 標籤中即可。


隨著 ajax 異步請求的出現，慢慢形成前後端分離。
	- 客戶端需要完成的事情越來越多，代碼量與日俱增。
	- 為了應對代碼量的劇增，我們通常會將代碼組織在多個 JS 文件中，進行維護。
	- 但是這種維護方式，依然不能避免一些災難性的問題。
	- 舉例:
	 	// aaa.js 文件中，小明定義了一個變量，名稱為 flag，並且為 true
		flag = true

		// bbb.js 文件中，小麗也喜歡用 flag 這個變量名稱，只是為 false
		flag = false
	
		// main.js 文件中，小明想通過 flag 進行一些判斷，完成後續的事情
		if(flag){
			console.log('小明是個天才')
		}

		小明後來發現代碼不能正常運行，去檢查自己的變量，發現確實為 true，
		最後悲劇發生了，小明加班到 2 點還是沒有找到問題出在哪裡，所以有
		些加班是毫無意義的。


匿名函數的解決方案
	- 我們可以使用匿名函數來解決上面的重名問題
		在 aaa.js 文件中，我們使用匿名函數
		(function(){
			var flag = true
		})()		

	- 但是如果我們希望在 main.js 文件中，用到 flag，應該如何處理 ?
		- 顯然，另外一個文件中不容易使用，因為 flag 是一個局部變量


使用模塊作為出口
    - 我們可以使用將需要暴露到外面的變量，使用一個模塊做為出口
    - 看看如下的代碼
        var ModuleA = (function(){
            // 1. 定義一個對象
            var obj = {}

            // 2. 在對象內部添加變量和方法
            obj.flag = true
            obj.myFunc = function(info) {
                console.log(info)
            }

            // 3. 將對象返回
            return obj
        })
    - 我們做了甚麼事情 ?
        - 非常簡單，在匿名函數內部，定義一個對象。
        - 給對象添加各種需要暴露到外面的屬性和方法。
        - 最後將這個對象返回，並且在外面使用一個 ModuleA 接收。

    - 接下來，我們在 main.js 中怎麼使用 ?
        - 我們只需要使用屬於自己模塊的屬性和方法即可
        if(ModuleA.flag){
            console.log('小明是個天才')
        }

        ModuleA.myFunc('小明長的真帥')

        console.log(ModuleA)

    - 這就是模塊化最基礎的封裝，事實上模塊的封裝還有很多高級的話題:
        - 但是我們這裡就只需要認識一下為什麼需要模塊化，以及模塊化的雛形。
        - 幸運的是，前端模塊化開發已經有了很多既有的規範，以及對應的實現方案。

    - 常見的模塊化的規範:
        CommonJS、AMD、CMD、也有 ES6 的 Modules

    - 模塊化有兩個核心：一個叫做導出、一個叫做導入。
        - 導出: 就是 aaa.js 中的 return obj
        - 導入: 就是 main.js 中的 使用 ModuleA 的部分

